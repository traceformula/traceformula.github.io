<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Game of Life + Controls Panel Minimize</title>
  <style>
    html, body {
      margin: 0;
      background: #111;
      overflow: hidden;
      font-family: sans-serif;
      color: white;
      height: 100%;
    }
    canvas {
      display: block;
      background: #222;
      cursor: crosshair;
    }
    #controls {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 6px;
      width: 200px;
      user-select: none;
      transition: height 0.3s ease;
      overflow: hidden;
      box-sizing: border-box;
    }
    #controls.minimized {
      height: 30px; /* just the header */
      padding: 6px 12px;
    }
    #controlsHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      font-weight: bold;
      font-size: 16px;
      margin-bottom: 8px;
      user-select: none;
    }
    #controlsContent {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    button, input[type="file"], input[type="range"] {
      font-size: 14px;
    }
    label {
      font-size: 13px;
    }
  </style>
</head>
<body>

<div id="controls">
  <div id="controlsHeader">
    Controls
    <button id="toggleBtn" title="Minimize/Expand" aria-label="Toggle Controls">â–²</button>
  </div>
  <div id="controlsContent">
    <button id="startStopBtn">Start</button>
    <button id="clearBtn">Clear</button>
    <label>
      Upload Image:
      <input type="file" id="imageInput" accept="image/*" />
    </label>
    <label>
      Brush Size (For Type "Dot"):
      <input type="range" id="brushSize" min="1" max="10" value="1" />
    </label>
    <label>
    Brush Type:
    <select id="brushType">
      <option value="spacefiller">Space Filler</option>
      <option value="dot">Dot</option>
      <option value="square">Square</option>
      <option value="glider">Glider</option>
      <option value="blinker">Blinker</option>
      <option value="phantom">Phantom</option>
      <option value="fractalizedPhantom">Fractalized Phantom</option>
      <option value="custom">Custom</option>
    </select>
  </label>

  <label>
    Rotation:
    <select id="rotation">
      <option value="0">0Â°</option>
      <option value="90">90Â°</option>
      <option value="180">180Â°</option>
      <option value="270">270Â°</option>
    </select>
  </label>

  <button id="editCustomBrushBtn">Edit Custom Brush</button>

  </div>
</div>

<div id="customBrushModal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#222; padding:20px; border:2px solid #555; z-index:20; color:white; text-align:center;">
  <h3>Edit Custom Brush</h3>
  <canvas id="brushCanvas" width="100" height="100" style="background:#000; margin-bottom:10px;"></canvas><br>
  <button id="saveBrushBtn">Save</button>
  <button id="closeBrushBtn">Cancel</button>
</div>

<div id="brushLibraryModal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#222; padding:20px; border:2px solid #555; z-index:20; color:white; text-align:left; width:300px;">
  <h3>Brush Library</h3>
  <div id="libraryList" style="max-height:200px; overflow-y:auto; margin-bottom:10px;"></div>
  <button id="closeLibraryBtn">Close</button>
</div>

<button id="openLibraryBtn" style="position:fixed; bottom:10px; left:10px; z-index:10;">ðŸ§± Brush Library</button>

<canvas id="gameCanvas"></canvas>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  let width = window.innerWidth;
  let height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;

  const CELL_SIZE = 2;
  const COLS = Math.floor(width / CELL_SIZE);
  const ROWS = Math.floor(height / CELL_SIZE);

  let grid = createEmptyGrid();
  let running = false;
  let interval = null;
  let brushSize = 1;

  let brushType = 'spacefiller';
  let brushRotation = 0;
  let customBrush = [[0, 0]];

  const brushes = {
    dot: [[0, 0]],
    square: [
      [-1, -1], [0, -1], [1, -1],
      [-1,  0], [0,  0], [1,  0],
      [-1,  1], [0,  1], [1,  1]
    ],
    glider: [
      [0, -1], [1, 0], [-1, 1], [0, 1], [1, 1]
    ],
    blinker: [
      [-1, 0], [0, 0], [1, 0]
    ],
    phantom: [
      [-1, -2], [-1, 2], [0, -1], [0, 1], [1, -1], [1, 1], [2, 0]
    ],
    spacefiller: [[0,5],[0,7],[1,4],[1,7],[2,3],[2,4],[3,2],[4,1],[4,2],[4,3],[4,4],[5,0],[5,5],[6,0],[6,3],[7,0],[7,3],[8,1],[8,11],[8,12],[8,13],[8,17],[8,18],[8,19],[9,2],[9,3],[9,4],[9,5],[9,7],[9,10],[9,13],[9,17],[9,20],[10,3],[10,7],[10,13],[10,17],[11,4],[11,13],[11,17],[12,4],[12,6],[12,13],[12,17],[14,3],[14,4],[14,5],[14,11],[14,12],[14,13],[14,17],[14,18],[14,19],[15,3],[15,4],[15,12],[15,18],[16,3],[16,4],[16,5],[16,12],[16,13],[16,14],[16,15],[16,16],[16,17],[16,18],[17,11],[17,19],[18,4],[18,6],[18,10],[18,11],[18,12],[18,13],[18,14],[18,15],[18,16],[18,17],[18,18],[18,19],[18,20],[19,3],[19,6],[19,9],[19,22],[19,23],[20,3],[20,9],[20,10],[20,11],[20,12],[20,13],[20,14],[20,15],[20,16],[20,17],[20,18],[20,19],[20,20],[20,24],[21,3],[21,7],[21,21],[21,25],[22,4],[22,8],[22,9],[22,10],[22,11],[22,12],[22,13],[22,14],[22,15],[22,16],[22,17],[22,18],[22,19],[22,25],[23,5],[23,6],[23,19],[23,22],[23,25],[24,8],[24,9],[24,10],[24,11],[24,12],[24,13],[24,14],[24,15],[24,16],[24,17],[24,18],[24,22],[24,24],[25,9],[25,17],[26,10],[26,11],[26,12],[26,13],[26,14],[26,15],[26,16],[26,23],[26,24],[26,25],[27,10],[27,16],[27,24],[27,25],[28,9],[28,10],[28,11],[28,15],[28,16],[28,17],[28,23],[28,24],[28,25],[30,11],[30,15],[30,22],[30,24],[31,11],[31,15],[31,24],[32,11],[32,15],[32,21],[32,25],[33,8],[33,11],[33,15],[33,18],[33,21],[33,23],[33,24],[33,25],[33,26],[34,9],[34,10],[34,11],[34,15],[34,16],[34,17],[34,27],[35,25],[35,28],[36,25],[36,28],[37,23],[37,28],[38,24],[38,25],[38,26],[38,27],[39,26],[40,24],[40,25],[41,21],[41,24],[42,21],[42,23]],
    custom: customBrush
  };

  brushes['fractalizedPhantom'] = fractalize(brushes['phantom'], fractalize(brushes['phantom'], brushes['phantom']));
  function fractalize(pattern, frame) {
    let minX = 1000000;
    let maxX = -1000000;
    let minY = 1000000;
    let maxY = -1000000;
    let res = [];
    for (const cell of pattern) {
      minX = Math.min(minX, cell[0]);
      maxX = Math.max(maxX, cell[0]);
      minY = Math.min(minY, cell[1]);
      maxY = Math.max(maxY, cell[1]);
    }

    const width = maxX - minX + 1;
    const height = maxY - minY + 1;
    for (const cell of frame) {
      topX = cell[0] * width;
      topY = cell[1] * height;
      for (const p of pattern) {
        res.push([topX + p[0] - minX, topY + p[1] - minY]);
      }
    }

    return res;
  }

  function rotatePattern(pattern, angle) {
    const rad = (angle * Math.PI) / 180;
    return pattern.map(([x, y]) => {
      const nx = Math.round(x * Math.cos(rad) - y * Math.sin(rad));
      const ny = Math.round(x * Math.sin(rad) + y * Math.cos(rad));
      return [nx, ny];
    });
  }

  function createEmptyGrid() {
    return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
  }

  function drawGrid() {
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = '#00ff88';
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        if (grid[y][x] === 1) {
          ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
      }
    }
  }

  function countNeighbors(grid, x, y) {
    let count = 0;
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
          count += grid[ny][nx];
        }
      }
    }
    return count;
  }

  function update() {
    const next = createEmptyGrid();
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const neighbors = countNeighbors(grid, x, y);
        const alive = grid[y][x] === 1;
        if (alive && (neighbors === 2 || neighbors === 3)) next[y][x] = 1;
        else if (!alive && neighbors === 3) next[y][x] = 1;
      }
    }
    grid = next;
    drawGrid();
  }

  document.getElementById('startStopBtn').addEventListener('click', () => {
    running = !running;
    document.getElementById('startStopBtn').textContent = running ? 'Pause' : 'Start';
    if (running) interval = setInterval(update, 100);
    else clearInterval(interval);
  });

  document.getElementById('clearBtn').addEventListener('click', () => {
    grid = createEmptyGrid();
    drawGrid();
  });

  let isDrawing = false;
  let drawMode = 1;

  canvas.addEventListener('mousedown', (e) => {
    e.preventDefault();
    isDrawing = true;
    drawMode = e.button === 2 ? 0 : 1;
    applyBrushFromMouse(e);
  });

  canvas.addEventListener('mousemove', (e) => {
    if (isDrawing) {
      applyBrushFromMouse(e);
    }
  });

  canvas.addEventListener('mouseup', () => (isDrawing = false));
  canvas.addEventListener('mouseleave', () => (isDrawing = false));
  canvas.addEventListener('contextmenu', (e) => e.preventDefault());

  function applyBrushFromMouse(e) {
    const rect = canvas.getBoundingClientRect();
    const cx = Math.floor((e.clientX - rect.left) / CELL_SIZE);
    const cy = Math.floor((e.clientY - rect.top) / CELL_SIZE);

    let pattern = brushType === 'dot' && brushSize > 1
      ? generateDotBrush(brushSize)
      : brushType === 'dot'
      ? [[0, 0]]
      : brushType === 'custom'
      ? customBrush
      : brushes[brushType];

    const rotated = rotatePattern(pattern, brushRotation);

    for (const [dx, dy] of rotated) {
      const x = cx + dx;
      const y = cy + dy;
      if (x >= 0 && x < COLS && y >= 0 && y < ROWS) {
        grid[y][x] = drawMode;
      }
    }

    drawGrid();
  }

  function generateDotBrush(size) {
    const half = Math.floor(size / 2);
    const result = [];
    for (let dy = -half; dy <= half; dy++) {
      for (let dx = -half; dx <= half; dx++) {
        result.push([dx, dy]);
      }
    }
    return result;
  }

  document.getElementById('imageInput').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const img = new Image();
    const reader = new FileReader();
    reader.onload = (event) => (img.src = event.target.result);
    reader.readAsDataURL(file);
    img.onload = () => {
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      tempCanvas.width = COLS;
      tempCanvas.height = ROWS;
      tempCtx.drawImage(img, 0, 0, COLS, ROWS);
      const imageData = tempCtx.getImageData(0, 0, COLS, ROWS).data;
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const i = (y * COLS + x) * 4;
          const brightness =
            (imageData[i] + imageData[i + 1] + imageData[i + 2]) / 3;
          grid[y][x] = brightness < 128 ? 1 : 0;
        }
      }
      drawGrid();
    };
  });

  document.getElementById('brushSize').addEventListener('input', (e) => {
    brushSize = parseInt(e.target.value);
  });

  document.getElementById('brushType').addEventListener('change', (e) => {
    brushType = e.target.value;
  });

  document.getElementById('rotation').addEventListener('change', (e) => {
    brushRotation = parseInt(e.target.value);
  });

  const brushCanvas = document.getElementById('brushCanvas');
  const brushCtx = brushCanvas.getContext('2d');
  const modal = document.getElementById('customBrushModal');
  let brushGrid = Array.from({ length: 10 }, () => Array(10).fill(0));

  function drawBrushEditor() {
    brushCtx.clearRect(0, 0, 100, 100);
    for (let y = 0; y < 10; y++) {
      for (let x = 0; x < 10; x++) {
        if (brushGrid[y][x]) {
          brushCtx.fillStyle = '#0f0';
          brushCtx.fillRect(x * 10, y * 10, 10, 10);
        }
        brushCtx.strokeStyle = '#555';
        brushCtx.strokeRect(x * 10, y * 10, 10, 10);
      }
    }
  }

  brushCanvas.addEventListener('click', (e) => {
    const rect = brushCanvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / 10);
    const y = Math.floor((e.clientY - rect.top) / 10);
    brushGrid[y][x] = brushGrid[y][x] ? 0 : 1;
    drawBrushEditor();
  });

  document.getElementById('editCustomBrushBtn').addEventListener('click', () => {
    modal.style.display = 'block';
    drawBrushEditor();
  });

  document.getElementById('closeBrushBtn').addEventListener('click', () => {
    modal.style.display = 'none';
  });

  document.getElementById('saveBrushBtn').addEventListener('click', () => {
    const pattern = [];
    for (let y = 0; y < 10; y++) {
      for (let x = 0; x < 10; x++) {
        if (brushGrid[y][x]) {
          pattern.push([x - 5, y - 5]); // Center at (0, 0)
        }
      }
    }
    const name = prompt("Name your custom brush:");
    if (name) {
      const savedBrushes = JSON.parse(localStorage.getItem('brushLibrary') || '{}');
      savedBrushes[name] = pattern;
      localStorage.setItem('brushLibrary', JSON.stringify(savedBrushes));
      alert(`Saved "${name}" to your library.`);
    }
    customBrush = pattern;
    brushes.custom = customBrush;
    modal.style.display = 'none';
  });

  const libraryModal = document.getElementById('brushLibraryModal');
  const openLibraryBtn = document.getElementById('openLibraryBtn');
  const closeLibraryBtn = document.getElementById('closeLibraryBtn');
  const libraryList = document.getElementById('libraryList');

  openLibraryBtn.addEventListener('click', () => {
    const saved = JSON.parse(localStorage.getItem('brushLibrary') || '{}');
    libraryList.innerHTML = '';

    Object.entries(saved).forEach(([name, pattern]) => {
      const row = document.createElement('div');
      row.style.marginBottom = '6px';

      const btn = document.createElement('button');
      btn.textContent = 'Use';
      btn.style.marginRight = '10px';
      btn.onclick = () => {
        customBrush = pattern;
        brushes.custom = customBrush;
        brushType = 'custom';
        document.getElementById('brushType').value = 'custom';
        libraryModal.style.display = 'none';
      };

      const label = document.createElement('span');
      label.textContent = name;

      row.appendChild(btn);
      row.appendChild(label);
      libraryList.appendChild(row);
    });

    libraryModal.style.display = 'block';
  });

  closeLibraryBtn.addEventListener('click', () => {
    libraryModal.style.display = 'none';
  });

  // Control panel minimize/expand
  const controls = document.getElementById('controls');
  const toggleBtn = document.getElementById('toggleBtn');
  const controlsContent = document.getElementById('controlsContent');

  let minimized = false;

  toggleBtn.addEventListener('click', () => {
    minimized = !minimized;
    if (minimized) {
      controls.classList.add('minimized');
      controlsContent.style.display = 'none';
      toggleBtn.textContent = 'â–¼';
    } else {
      controls.classList.remove('minimized');
      controlsContent.style.display = 'flex';
      toggleBtn.textContent = 'â–²';
    }
  });

  drawGrid();

  // Optional: handle window resize
  window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    drawGrid();
  });
</script>

</body>
</html>
